<?php

namespace pz\Routing;

use Exception;
use pz\Enums\Routing\{Privacy, Method, ResponseCode};
use pz\Routing\Response;

class Route {
    protected String $path;
    protected Array $methods;
    protected Privacy $privacy;
    protected ?String $controller;
    protected ?String $action_model;
    protected ?String $function;
    protected ?String $success_location;
    protected ?String $error_location;
    protected Response $response;
    protected Request $request;

    /**
     * Constructor for the Route class.
     *
     * @param String $path The path for the route.
     * @param Method|Array $method The HTTP method(s) for the route. Defaults to Method::GET.
     * @param Privacy $privacy The privacy level of the route. Defaults to Privacy::PROTECTED.
     * @param ?String $controller The controller class for the route. Defaults to null.
     * @param ?String $function The function to be called in the controller. Defaults to null.
     * @param ?String $default_success_location The default location to redirect on success. Defaults to null.
     * @param ?String $default_error_location The default location to redirect on error. Defaults to null.
     *
     * @throws Exception If a controller is defined but no function is given.
     * @throws Exception If the controller is not a subclass of pz\Controller.
     */
    public function __construct(String $path, Method|Array $method = Method::GET, Privacy $privacy = Privacy::PROTECTED, ?String $controller = null, ?String $function = null, ?String $default_success_location = null, ?String $default_error_location = null) {        
        $this->path = $path;
        $this->setMethods($method);
        $this->privacy = $privacy;

        $this->controller = $controller;
        
        if($controller !== null) {
            if($function === null) {
                throw new Exception('Invalid action : '.$path.' - Controller defined but no method to reach was given.');
            }
            if (!is_subclass_of($this->controller, 'pz\Controller')) {
                throw new Exception('Invalid action : '.$path.' - The route\'s controller must be a subclass of Controller.');
            }
        }

        $this->action_model = null;
        $this->function = $function;
        $this->success_location = $default_success_location;
        $this->error_location = $default_error_location;
        $this->response = new Response(true, ResponseCode::Ok);
    }

    /**
     * Checks the request and returns an appropriate response.
     *
     * This method performs the following checks:
     * 1. Verifies if the request method is allowed. If not, it sets the response to an invalid request method response.
     * 2. Checks if the requested resource requires login and if the user is not logged in. If so, it sets the response to an unauthorized response.
     *
     * @param Request $request The incoming request to be checked.
     * @return Response The response object indicating the result of the checks.
     */
    public function check(Request $request): Response {
        // Check if the request method is allowed
        if(!$this->hasMethod($request->getMethod())) {
            $this->response = new Response(false, ResponseCode::InvalidRequestMethod, null, 'Invalid request method '.$request->getMethod()->value, '/index.php');
        }
    
        // Check if the request requires login and the user is not logged in
        if($this->privacy->requiresLogin() && $request->user() === null) {
            $this->response = new Response(false, ResponseCode::Unauthorized, null, 'Unauthorized : you must be logged in to access this page', '/index.php');
        }

        return $this->response;
    }

    /**
     * Serves the given request and returns a response.
     *
     * @param Request $request The HTTP request to be served.
     * @return Response The HTTP response generated by the controller.
     *
     * This method processes the incoming request by finding any necessary redirects,
     * invoking the appropriate controller and function, and handling the response.
     * If the controller's response is not an instance of Response, it wraps it in a Response object.
     * It also sets redirects based on the success or failure of the response.
     */
    public function serve(Request $request): Response {
        $this->request = $request;
        $this->find_redirects($request);
        $controller = $this->getController();
        $function = $this->getFunction();

        // Call the controller's function with the request
        $controller_response = $controller->$function($request);
        if($controller_response instanceof Response) {
            $this->response = $controller_response;
        } else {
            $this->response =  new Response(true, ResponseCode::Ok, $controller_response);
        }

        // Set the redirect location based on the response
        if($this->response->isSuccessful() && !$this->response->hasRedirect() && $this->success_location != null) {
            $this->response->setRedirect($this->success_location);
        }
        if(!$this->response->isSuccessful() && !$this->response->hasRedirect() && $this->error_location != null) {
            $this->response->setRedirect($this->error_location);
        }

        return $this->response;
    }

    ##############################
    # Helpers and Utilities
    ##############################
    /**
     * Finds and sets the redirect locations based on the given request.
     *
     * This method checks the request for success and error locations. If found, it sets the corresponding properties of the class.
     *
     * @param Request $request The request object containing potential redirect locations.
     */
    protected function find_redirects(Request $request) {
        $success_location = $request->successLocation();
        $error_location = $request->errorLocation();

        if($success_location !== null) {
            $this->success_location = $success_location;
        }
        if($error_location !== null) {
            $this->error_location = $error_location;
        }
    }

    /**
     * Converts the route object to an associative array.
     *
     * @return array An associative array containing the route details:
     *      - 'url' (string): The path of the route.
     *      - 'method' (array): The HTTP methods allowed for the route.
     *      - 'privacy' (string): The privacy level of the route.
     *      - 'controller' (string|null): The controller associated with the route, if any.
     *      - 'function' (string|null): The function to be called in the controller, if any.
     */
    public function toArray() {
        $data = [
            'url' => $this->path,
            'method' => $this->methods,
            'privacy' => $this->privacy,
            // 'default_success_location' => $this->default_success_location,
            // 'default_error_location' => $this->default_error_location
        ];
        if($this->controller !== null) {
            $data['controller'] = $this->controller;
            $data['function'] = $this->function;
        }

        return $data;
    }    

    ##############################
    # Getters and Setters
    ##############################
    public function setPrivacy(Privacy $privacy) {
        $this->privacy = $privacy;
    }

    public function getPrivacy() {
        return $this->privacy;
    }
    
    public function setMethods(Method|Array $method) {
        if(is_array($method)) {
            foreach($method as $m) {
                if(!($m instanceof Method)) {
                    throw new Exception('Invalid method : '.$m.' - The method must be an instance of Method.');
                }
            }
            $this->methods = $method;
        } else {
            $this->methods = [$method];
        }
    }

    public function addMethod(Method $method) {
        if($this->hasMethod($method)) {
            return;
        }
        $this->methods[] = $method;
    }

    public function getMethods() {
        return $this->methods;
    }

    public function hasMethod(Method $method): bool {
        return in_array($method, $this->methods);
    }

    public function setPath(String $path) {
        $this->path = $path;
    }

    public function getPath() {
        return $this->path;
    }

    public function getController() {
        $controller = new $this->controller;
        if($this->action_model !== null) {
            $controller->setModel($this->action_model);
        }

        return $controller;
    }

    public function setModel($model) {
        $this->action_model = $model;
    }

    public function getFunction() {
        return $this->function;
    }

    public function getResponse() {
        return $this->response;
    }

    public function getRequest() {
        return $this->request;
    }
}